use crate::ecs::resources::Resources;
use crate::ecs::system::System;
use crate::ecs::with_resources::WithResources;
use anyhow::Error;

use async_trait::async_trait;
use futures::{StreamExt};
use log::{info, trace};
use std::future::{ready, Future};
use std::net::{IpAddr, Ipv6Addr, SocketAddr};
use std::time::Duration;
use tarpc::context::Context;
use tarpc::server::incoming::Incoming;
use tarpc::server::{BaseChannel, Channel};
use tarpc::tokio_serde::formats::Json;


#[derive(Debug)]
pub struct Rpc {
    listener: async_std::task::JoinHandle<()>,
}

#[async_trait]
impl System for Rpc {
    async fn run(&mut self, _res: &Resources, _t: Duration, _dt: Duration) {}
}

impl WithResources for Rpc {
    async fn with_res(_res: &Resources) -> Result<Self, Error> {
        let server_addr = (IpAddr::V6(Ipv6Addr::LOCALHOST), 0);
        let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Json::default).await?;
        info!("Listening on port {}", listener.local_addr().port());
        listener.config_mut().max_frame_length(usize::MAX);
        let join_handle: async_std::task::JoinHandle<()> = async_std::task::spawn(async move {
            trace!("Starting RPC listener");
            listener
                // Ignore accept errors.
                .filter_map(|r| ready(r.ok()))
                .map(BaseChannel::with_defaults)
                // Limit channels to 1 per IP.
                .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
                // serve is generated by the service attribute. It takes as input any type implementing
                // the generated World trait.
                .map(|channel| {
                    let connection = RpcConnection { socket_address: channel.transport().peer_addr().unwrap() };
                    channel.execute(connection.serve()).for_each(spawn_wrapped)
                })
                // Max 10 channels.
                .buffer_unordered(10)
                .for_each(|_| async { })
                .await;
        });

        Ok(Rpc { listener: join_handle })
    }
}

#[tarpc::service]
trait RpcService {
    /// Returns a greeting for name.
    async fn hello(name: String) -> String;
}

#[derive(Debug, Clone)]
struct RpcConnection {
    socket_address: SocketAddr,
}

impl RpcService for RpcConnection {
    async fn hello(self, _context: Context, name: String) -> String {
        format!("Hello, {}", name)
    }
}

async fn spawn_wrapped(fut: impl Future<Output = ()> + Send + 'static) {
    tokio::task::spawn(fut);
}
