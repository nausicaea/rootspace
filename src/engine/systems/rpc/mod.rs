mod message;
mod server;
pub mod service;

use crate::ecs::resources::Resources;
use crate::ecs::system::System;
use crate::ecs::with_resources::WithResources;
use anyhow::Error;

use crate::engine::resources::rpc_settings::RpcSettings;
use crate::engine::systems::rpc::server::RpcServer;
use crate::engine::systems::rpc::service::RpcService;
use async_trait::async_trait;
use futures::StreamExt;
use log::{info, trace};
use message::RpcMessage;
use std::future::ready;

use std::time::Duration;

use tarpc::server::incoming::Incoming;
use tarpc::server::{BaseChannel, Channel};
use tarpc::tokio_serde::formats::Json;
use tokio::sync::mpsc::error::TryRecvError;
use tokio::sync::mpsc::{Receiver};
use tokio::task::JoinHandle;
use crate::ecs::event_queue::EventQueue;
use crate::engine::events::engine_event::EngineEvent;

#[derive(Debug)]
pub struct Rpc {
    listener_handle: JoinHandle<()>,
    mpsc_rx: Receiver<RpcMessage>,
}

#[async_trait]
impl System for Rpc {
    async fn run(&mut self, res: &Resources, _t: Duration, _dt: Duration) {
        'recv: loop {
            match self.mpsc_rx.try_recv() {
                Ok(RpcMessage::Hello(name, addr)) => info!("Hello from {}@{}", name, addr),
                Ok(RpcMessage::Exit) => res.write::<EventQueue<EngineEvent>>().send(EngineEvent::Exit),
                Err(TryRecvError::Empty | TryRecvError::Disconnected) => break 'recv,
            }
        }
    }
}

impl WithResources for Rpc {
    async fn with_res(res: &Resources) -> Result<Self, Error> {
        let (ba, mfl, mcc, mcpk, rcc) = {
            let settings = res.read::<RpcSettings>();
            (
                settings.bind_address,
                settings.max_frame_length,
                settings.mpsc_channel_capacity,
                settings.max_channels_per_key,
                settings.rpc_channel_capacity,
            )
        };

        let mut listener = tarpc::serde_transport::tcp::listen(&ba, Json::default).await?;
        info!("RPC binding to {}", listener.local_addr());
        listener.config_mut().max_frame_length(mfl);
        let (tx, rx) = tokio::sync::mpsc::channel(mcc);
        let join_handle: JoinHandle<()> = tokio::task::spawn(async move {
            trace!("Starting RPC listener");
            listener
                // Ignore accept errors.
                .filter_map(|r| ready(r.ok()))
                .map(|r| BaseChannel::with_defaults(r))
                // Limit channels to 1 per IP and Port.
                .max_channels_per_key(mcpk, |t| t.transport().peer_addr().unwrap())
                // serve is generated by the service attribute. It takes as input any type implementing
                // the generated RpcService trait.
                .map(|channel| {
                    let connection = RpcServer::new(
                        tx.clone(),
                        channel.transport().peer_addr().unwrap(),
                    );
                    channel.execute(connection.serve()).for_each(|fut| async {
                        tokio::task::spawn(fut);
                    })
                })
                // Max 10 channels.
                .buffer_unordered(rcc)
                .for_each(|_| async { })
                .await;
        });

        Ok(Rpc {
            listener_handle: join_handle,
            mpsc_rx: rx,
        })
    }
}
