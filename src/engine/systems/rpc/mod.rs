mod message;
mod server;
pub mod service;

use std::{future::ready, time::Duration};

use anyhow::Error;
use async_trait::async_trait;
use futures::StreamExt;
use log::{info, trace};
use message::RpcMessage;
use tarpc::server::{incoming::Incoming, BaseChannel, Channel};
use tokio::{sync::mpsc, task::JoinHandle};

use crate::{
    ecs::{
        event_queue::{receiver_id::ReceiverId, EventQueue},
        resources::Resources,
        system::System,
        with_resources::WithResources,
    },
    engine::{
        assets::scene::Scene,
        events::engine_event::EngineEvent,
        resources::{asset_database::AssetDatabase, rpc_settings::RpcSettings, statistics::Statistics},
        systems::rpc::{server::RpcServer, service::RpcService},
    },
};

#[derive(Debug)]
pub struct Rpc {
    rpc_listener: JoinHandle<()>,
    mpsc_rx: mpsc::Receiver<RpcMessage>,
    receiver: ReceiverId<EngineEvent>,
}

#[async_trait]
impl System for Rpc {
    async fn run(&mut self, res: &Resources, _t: Duration, _dt: Duration) {
        let events = res.write::<EventQueue<EngineEvent>>().receive(&self.receiver);
        for event in events {
            #[allow(irrefutable_let_patterns)]
            if let EngineEvent::Exit = event {
                trace!("Stopping RPC listener");
                self.rpc_listener.abort();
            }
        }

        while let Ok(msg) = self.mpsc_rx.try_recv() {
            trace!("RPC incoming call: {:?}", &msg);
            match msg {
                RpcMessage::StatsRequest(tx) => {
                    let stats = res.read::<Statistics>().clone();
                    tx.send(stats).unwrap();
                }
                RpcMessage::LoadScene { tx, group, name } => {
                    let r = res
                        .read::<AssetDatabase>()
                        .load_asset::<Scene, _>(res, &group, &name)
                        .await;
                    tx.send(r).unwrap();
                }
                RpcMessage::Exit => res.write::<EventQueue<EngineEvent>>().send(EngineEvent::Exit),
            }
        }
    }
}

impl WithResources for Rpc {
    async fn with_res(res: &Resources) -> Result<Self, Error> {
        let (ba, mfl, mcc, mcpk, rcc) = {
            let settings = res.read::<RpcSettings>();
            (
                settings.bind_address,
                settings.max_frame_length,
                settings.mpsc_channel_capacity,
                settings.max_channels_per_key,
                settings.rpc_channel_capacity,
            )
        };
        let receiver = res.write::<EventQueue<EngineEvent>>().subscribe::<Self>();

        let mut listener =
            tarpc::serde_transport::tcp::listen(&ba, tarpc::tokio_serde::formats::Bincode::default).await?;
        info!("RPC binding to {}", listener.local_addr());
        listener.config_mut().max_frame_length(mfl);
        let (tx, rx) = tokio::sync::mpsc::channel::<RpcMessage>(mcc);
        let rpc_listener: JoinHandle<()> = tokio::task::spawn(async move {
            trace!("Starting RPC listener");
            listener
                // Ignore accept errors.
                .filter_map(|r| ready(r.ok()))
                .map(BaseChannel::with_defaults)
                // Limit channels to 1 per IP and Port.
                .max_channels_per_key(mcpk, |t| t.transport().peer_addr().unwrap())
                // serve is generated by the service attribute. It takes as input any type implementing
                // the generated RpcService trait.
                .map(|channel| {
                    let connection = RpcServer::new(
                        tx.clone(),
                        channel.transport().peer_addr().unwrap(),
                    );
                    channel.execute(connection.serve()).for_each(|fut| async {
                        tokio::task::spawn(fut);
                    })
                })
                // Max 10 channels.
                .buffer_unordered(rcc)
                .for_each(|_| async { })
                .await;
        });

        Ok(Rpc {
            rpc_listener,
            mpsc_rx: rx,
            receiver,
        })
    }
}
