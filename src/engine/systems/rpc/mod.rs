mod message;
mod server;
pub mod service;

use crate::ecs::resources::Resources;
use crate::ecs::system::System;
use crate::ecs::with_resources::WithResources;
use anyhow::Error;

use crate::engine::resources::rpc_settings::RpcSettings;
use crate::engine::systems::rpc::server::RpcServer;
use crate::engine::systems::rpc::service::RpcService;
use async_trait::async_trait;
use futures::StreamExt;
use log::{info, trace};
use message::RpcMessage;
use std::future::ready;

use std::time::Duration;

use crate::ecs::event_queue::receiver_id::ReceiverId;
use crate::ecs::event_queue::EventQueue;
use crate::engine::events::engine_event::EngineEvent;
use crate::engine::resources::statistics::Statistics;
use tarpc::server::incoming::Incoming;
use tarpc::server::{BaseChannel, Channel};
use tarpc::tokio_serde::formats::Json;
use tokio::sync::mpsc::error::TryRecvError;
use tokio::sync::mpsc::Receiver;
use tokio::task::JoinHandle;

#[derive(Debug)]
pub struct Rpc {
    listener_handle: JoinHandle<()>,
    mpsc_rx: Receiver<RpcMessage>,
    receiver: ReceiverId<EngineEvent>,
}

#[async_trait]
impl System for Rpc {
    async fn run(&mut self, res: &Resources, _t: Duration, _dt: Duration) {
        let events = res.write::<EventQueue<EngineEvent>>().receive(&self.receiver);
        for event in events {
            if let EngineEvent::Exit = event {
                trace!("Stopping RPC listener");
                self.listener_handle.abort();
            }
        }

        'recv: loop {
            match self.mpsc_rx.try_recv() {
                Ok(msg) => {
                    trace!("RPC incoming call: {:?}", &msg);
                    match msg {
                        RpcMessage::Hello(name, addr) => info!("Hello from {}@{}", name, addr),
                        RpcMessage::StatsRequest(tx) => {
                            let stats = res.read::<Statistics>().clone();
                            tx.send(stats).unwrap();
                        }
                        RpcMessage::Exit => res.write::<EventQueue<EngineEvent>>().send(EngineEvent::Exit),
                    }
                }
                Err(TryRecvError::Empty | TryRecvError::Disconnected) => break 'recv,
            }
        }
    }
}

impl WithResources for Rpc {
    async fn with_res(res: &Resources) -> Result<Self, Error> {
        let (ba, mfl, mcc, mcpk, rcc) = {
            let settings = res.read::<RpcSettings>();
            (
                settings.bind_address,
                settings.max_frame_length,
                settings.mpsc_channel_capacity,
                settings.max_channels_per_key,
                settings.rpc_channel_capacity,
            )
        };
        let receiver = res.write::<EventQueue<EngineEvent>>().subscribe::<Self>();

        let mut listener = tarpc::serde_transport::tcp::listen(&ba, Json::default).await?;
        info!("RPC binding to {}", listener.local_addr());
        listener.config_mut().max_frame_length(mfl);
        let (tx, rx) = tokio::sync::mpsc::channel(mcc);
        let join_handle: JoinHandle<()> = tokio::task::spawn(async move {
            trace!("Starting RPC listener");
            listener
                // Ignore accept errors.
                .filter_map(|r| ready(r.ok()))
                .map(BaseChannel::with_defaults)
                // Limit channels to 1 per IP and Port.
                .max_channels_per_key(mcpk, |t| t.transport().peer_addr().unwrap())
                // serve is generated by the service attribute. It takes as input any type implementing
                // the generated RpcService trait.
                .map(|channel| {
                    let connection = RpcServer::new(
                        tx.clone(),
                        channel.transport().peer_addr().unwrap(),
                    );
                    channel.execute(connection.serve()).for_each(|fut| async {
                        tokio::task::spawn(fut);
                    })
                })
                // Max 10 channels.
                .buffer_unordered(rcc)
                .for_each(|_| async { })
                .await;
        });

        Ok(Rpc {
            listener_handle: join_handle,
            mpsc_rx: rx,
            receiver,
        })
    }
}
