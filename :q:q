//! Provides the resource manager.

use crate::{components::Component, persistence::Persistence, registry::Registry, resource::Resource};
use serde::{
    de::{self, Deserializer, MapAccess, Visitor},
    ser::{self, Serialize, SerializeMap, SerializeStruct, Serializer},
    Deserialize,
};
use std::{
    any::TypeId,
    cell::{Ref, RefCell, RefMut},
    collections::HashMap,
    fmt,
    marker::PhantomData,
};
use typename::TypeName;
use log::{debug, trace};

/// A container that manages resources. Allows mutable borrows of multiple different resources at
/// the same time.
#[derive(Default, Debug)]
pub struct Resources {
    resources: HashMap<TypeId, RefCell<Box<dyn Resource>>>,
    persistences: HashMap<TypeId, Persistence>,
}

impl Resources {
    pub fn serialize<RR, S>(&self, serializer: S) -> Result<(), S::Error>
    where
        RR: Registry + Default,
        S: Serializer,
    {
        struct SerContainer<'a, R> {
            persistence: Persistence,
            resource: &'a R,
        }

        impl<'a, R> SerContainer<'a, R> {
            fn new(p: Persistence, r: &'a R) -> Self {
                SerContainer {
                    persistence: p,
                    resource: r,
                }
            }
        }

        impl<'a, R> Serialize for SerContainer<'a, R>
        where
            R: Resource + Serialize,
        {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: Serializer,
            {
                let mut state = serializer.serialize_struct("SerContainer", 2)?;
                state.serialize_field("persistence", &self.persistence)?;
                state.serialize_field("resource", self.resource)?;
                state.end()
            }
        }

        fn serialize_entry<SM, R>(res: &Resources, state: &mut SM, _entry: &R) -> Result<(), SM::Error>
        where
            SM: SerializeMap,
            R: Resource + TypeName + Serialize,
        {
            if res.has::<R>() {
                state.serialize_entry(
                    &R::type_name(),
                    &SerContainer::new(res.persistence_of::<R>(), &*res.borrow::<R>()),
                )?;
                Ok(())
            } else {
                Err(ser::Error::custom(format!("resource {} was not found", R::type_name())))
            }
        }

        fn recurse<SM, RR>(res: &Resources, state: &mut SM, reg: &RR) -> Result<(), SM::Error>
        where
            SM: SerializeMap,
            RR: Registry,
        {
            if RR::LEN > 0 {
                let head = reg.head();
                trace!("Serializing the resource {}", &head.type_name_of());
                serialize_entry(res, state, head)?;
                recurse(res, state, reg.tail())
            } else {
                Ok(())
            }
        }

        debug!("Beginning the serialization of Resources");
        let reg: RR = Default::default();
        let mut state = serializer.serialize_map(Some(RR::LEN))?;
        recurse(self, &mut state, &reg)?;
        state.end()?;
        debug!("Completed the serialization of Resources");
        Ok(())
    }

    pub fn deserialize<'de, RR, D>(deserializer: D) -> Result<Self, D::Error>
    where
        RR: Registry + Default,
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct DeContainer<R> {
            persistence: Persistence,
            resource: R,
        }

        fn deserialize_element<'de, A, R>(res: &mut Resources, access: &mut A, _entry: &R) -> Result<(), A::Error>
        where
            A: MapAccess<'de>,
            R: Resource + TypeName + Deserialize<'de>,
        {
            let c = access.next_value::<DeContainer<R>>()?;
            res.insert(c.resource, c.persistence);
            Ok(())
        }

        fn recurse<'de, A, RR>(res: &mut Resources, access: &mut A, key: &str, reg: &RR) -> Result<(), A::Error>
        where
            A: MapAccess<'de>,
            RR: Registry,
        {
            if RR::LEN > 0 {
                let head = reg.head();
                if key == head.type_name_of() {
                    deserialize_element(res, access, head)
                } else {
                    recurse(res, access, key, reg.tail())
                }
            } else {
                Err(de::Error::unknown_field(key, &[]))
            }
        }

        struct ResourcesVisitor<RR>(PhantomData<RR>);

        impl<RR> Default for ResourcesVisitor<RR> {
            fn default() -> Self {
                ResourcesVisitor(PhantomData::default())
            }
        }

        impl<'de, RR> Visitor<'de> for ResourcesVisitor<RR>
        where
            RR: Registry + Default,
        {
            type Value = Resources;

            fn expecting(&self, f: &mut fmt::Formatter) -> fmt::Result {
                write!(
                    f,
                    "a map of type names and their serialized data including a persistence marker"
                )
            }

            fn visit_map<A>(self, mut access: A) -> Result<Self::Value, A::Error>
            where
                A: MapAccess<'de>,
            {
                let reg: RR = Default::default();
                let mut resources = Resources::with_capacity(access.size_hint().unwrap_or(RR::LEN));

                while let Some(key) = access.next_key::<String>()? {
                    trace!("Deserializing the resource {}", &key);
                    recurse(&mut resources, &mut access, &key, &reg)?;
                }

                Ok(resources)
            }
        }

        debug!("Beginning the deserialization of Resources");
        deserializer.deserialize_map(ResourcesVisitor::<RR>::default())
        debug!("Completed the deserialization of Resources");
    }

    /// Create a new, empty resources container.
    pub fn new() -> Self {
        Default::default()
    }

    /// Create a new resources container with the specified capacity.
    pub fn with_capacity(cap: usize) -> Self {
        Resources {
            resources: HashMap::with_capacity(cap),
            persistences: HashMap::with_capacity(cap),
        }
    }

    /// Join the resources from another container.
    pub fn join(&mut self, resources: Self) {
        for (k, v) in resources.resources {
            self.resources.insert(k, v);
        }
        for (k, v) in resources.persistences {
            self.persistences.insert(k, v);
        }
    }

    /// Empty the resource manager.
    pub fn clear(&mut self, persistence: Persistence) {
        let persistences = &self.persistences;
        self.resources.retain(|id, _| persistences[id] >= persistence)
    }

    /// Insert a new resource.
    pub fn insert<R>(&mut self, res: R, persistence: Persistence)
    where
        R: Resource + TypeName,
    {
        self.resources.insert(TypeId::of::<R>(), RefCell::new(Box::new(res)));
        self.persistences.insert(TypeId::of::<R>(), persistence);
    }

    /// Removes the resource of the specified type.
    pub fn remove<R>(&mut self)
    where
        R: Resource + TypeName,
    {
        self.resources.remove(&TypeId::of::<R>());
        self.persistences.remove(&TypeId::of::<R>());
    }

    /// Returns `true` if a resource of the specified type is present.
    pub fn has<R>(&self) -> bool
    where
        R: Resource,
    {
        self.resources.contains_key(&TypeId::of::<R>())
    }

    /// Returns the persistence of the specified resource type.
    pub fn persistence_of<R>(&self) -> Persistence
    where
        R: Resource + TypeName,
    {
        *self
            .persistences
            .get(&TypeId::of::<R>())
            .expect(&format!("Could not find any resource of type {}", R::type_name()))
    }

    /// Borrows the requested resource.
    pub fn borrow<R>(&self) -> Ref<R>
    where
        R: Resource + TypeName,
    {
        self.resources
            .get(&TypeId::of::<R>())
            .map(|r| {
                Ref::map(r.borrow(), |i| {
                    i.downcast_ref::<R>().expect(&format!(
                        "Could not downcast the requested resource to type {}",
                        R::type_name()
                    ))
                })
            })
            .expect(&format!("Could not find any resource of type {}", R::type_name()))
    }

    /// Mutably borrows the requested resource (with a runtime borrow check).
    pub fn borrow_mut<R>(&self) -> RefMut<R>
    where
        R: Resource + TypeName,
    {
        self.resources
            .get(&TypeId::of::<R>())
            .map(|r| {
                RefMut::map(r.borrow_mut(), |i| {
                    i.downcast_mut::<R>().expect(&format!(
                        "Could not downcast the requested resource to type {}",
                        R::type_name()
                    ))
                })
            })
            .expect(&format!("Could not find any resource of type {}", R::type_name()))
    }

    /// Mutably borrows the requested resource (with a compile-time borrow check).
    pub fn get_mut<R>(&mut self) -> &mut R
    where
        R: Resource + TypeName,
    {
        self.resources
            .get_mut(&TypeId::of::<R>())
            .map(|r| {
                r.get_mut().downcast_mut::<R>().expect(&format!(
                    "Could not downcast the requested resource to type {}",
                    R::type_name()
                ))
            })
            .expect(&format!("Could not find any resource of type {}", R::type_name()))
    }

    /// Borrows the requested component storage (this is a convenience method to `borrow`).
    pub fn borrow_component<C>(&self) -> Ref<C::Storage>
    where
        C: Component + TypeName,
        C::Storage: TypeName,
    {
        self.borrow::<C::Storage>()
    }

    /// Mutably borrows the requested component storage (this is a convenience method to
    /// `borrow_mut`).
    pub fn borrow_mut_component<C>(&self) -> RefMut<C::Storage>
    where
        C: Component + TypeName,
        C::Storage: TypeName,
    {
        self.borrow_mut::<C::Storage>()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::Reg;
    use serde::{Deserialize, Serialize};
    use serde_json;

    #[derive(Debug, Default, TypeName, Serialize, Deserialize, PartialEq)]
    struct TestResourceA(usize);

    #[derive(Debug, Default, TypeName, Serialize, Deserialize, PartialEq)]
    struct TestResourceB(f32);

    #[derive(Debug, Default, TypeName, Serialize, Deserialize, PartialEq)]
    struct TestResourceC(String);

    type TestRegistry = Reg![TestResourceA, TestResourceB, TestResourceC,];

    #[test]
    fn persistence() {
        assert!(Persistence::None < Persistence::Runtime);
    }

    #[test]
    fn default() {
        let _: Resources = Default::default();
    }

    #[test]
    fn insert() {
        let mut resources = Resources::default();
        resources.insert(TestResourceA::default(), Persistence::Runtime);
    }

    #[test]
    fn borrow() {
        let mut resources = Resources::default();
        resources.insert(TestResourceA::default(), Persistence::Runtime);

        let _: Ref<TestResourceA> = resources.borrow();
    }

    #[test]
    fn serialize() {
        let mut resources = Resources::default();
        resources.insert(TestResourceA(25), Persistence::Runtime);
        resources.insert(TestResourceB(0.141), Persistence::None);
        resources.insert(TestResourceC(String::from("Bye")), Persistence::None);

        let mut writer: Vec<u8> = Vec::with_capacity(128);
        let mut s = serde_json::Serializer::new(&mut writer);
        assert!(resources.serialize::<TestRegistry, _>(&mut s).is_ok());
        assert_eq!(
            unsafe { String::from_utf8_unchecked(writer) },
            "{\"ecs::resources::tests::TestResourceA\":{\"persistence\":\"Runtime\",\"resource\":25},\"ecs::resources::tests::TestResourceB\":{\"persistence\":\"None\",\"resource\":0.141},\"ecs::resources::tests::TestResourceC\":{\"persistence\":\"None\",\"resource\":\"Bye\"}}"
        );
    }

    #[test]
    fn deserialize() {
        let mut d = serde_json::Deserializer::from_slice(
            b"{\"ecs::resources::tests::TestResourceA\":{\"persistence\":\"Runtime\",\"resource\":10},\"ecs::resources::tests::TestResourceB\":{\"persistence\":\"None\",\"resource\":0.25},\"ecs::resources::tests::TestResourceC\":{\"persistence\":\"None\",\"resource\":\"Hello, World!\"}}",
        );
        let resources = Resources::deserialize::<TestRegistry, _>(&mut d).unwrap();
        assert!(d.end().is_ok());
        assert_eq!(*resources.borrow::<TestResourceA>(), TestResourceA(10));
        assert_eq!(*resources.borrow::<TestResourceB>(), TestResourceB(0.25));
        assert_eq!(
            *resources.borrow::<TestResourceC>(),
            TestResourceC(String::from("Hello, World!"))
        );
    }
}
